{
    "docs": [
        {
            "location": "/", 
            "text": "RAD.jl Documentation\n\n\nRAD.jl\n is a package with utilities for next generation sequencing.\n\n\n\n\nPrimary Clustering and Pipeline Functions\n\n\n\n\nConsensus and Fine Cluster Splitting Functions\n\n\n\n\n\n\nRAD.are_homopolymers\n\n\n\n\nRAD.cluster_split\n\n\nRAD.clusterpipeline\n\n\nRAD.denoise\n\n\nRAD.fine_clustering\n\n\nRAD.gen_arrangements\n\n\nRAD.get_ave_dists\n\n\nRAD.get_non_homopolymers\n\n\nRAD.kmer_split_clustering\n\n\nRAD.kmer_split_consensus", 
            "title": "Home"
        }, 
        {
            "location": "/#radjl-documentation", 
            "text": "RAD.jl  is a package with utilities for next generation sequencing.   Primary Clustering and Pipeline Functions   Consensus and Fine Cluster Splitting Functions    RAD.are_homopolymers   RAD.cluster_split  RAD.clusterpipeline  RAD.denoise  RAD.fine_clustering  RAD.gen_arrangements  RAD.get_ave_dists  RAD.get_non_homopolymers  RAD.kmer_split_clustering  RAD.kmer_split_consensus", 
            "title": "RAD.jl Documentation"
        }, 
        {
            "location": "/clusterpipeline/", 
            "text": "Primary Clustering and Pipeline Functions\n\n\n\n\nRAD.clusterpipeline\n\n\nRAD.denoise\n\n\nRAD.get_ave_dists\n\n\nRAD.kmer_split_clustering\n\n\nRAD.kmer_split_consensus\n\n\n\n\n#\n\n\nRAD.denoise\n \n \nFunction\n.\n\n\ndenoise(seqs; \nkeyword arguments\n )\n\n                rough_radius::Float64 = 0.01,\n                fine_radius::Float64 = 1.0,\n                reassign::Bool = true,\n                clust_multiplier::Float64 = 1.0,\n                min_devs::Int64 = 6,\n                initial_devs::Int64 = 20,\n                user_min_clust::Int64 = 5,\n                k::Int64 = 6,\n                distfunc = euclidean,\n                center = mean,\n                verbose::Int64 = 1,\n                cycle_lim = 20,\n                triangle::Bool = false,\n                degap_param::Bool = false,\n                Polish::Bool = true,\n                p_value::Float64 = 0.01\n\n\n\n\nArguments\n\n\n\n\nseqs\n: array containing the sequences to be operated on\n\n\nrough_radius::Float64\n: distance between SNPs used in fine clustering\n\n\nfine_radius::Float64\n: distance between SNPs used in rough clustering\n\n\nreassign::Bool = true\n: indicates whether or not to reassign the rough singletons\n\n\n\n\nback to consensus sequences\n\n\n\n\nclust_multiplier::Float64 = 1.0\n: minimum non-error cluster size\n\n\nmin_devs::Int64 = 6\n: number of high standard deviation kmer to fine cluster on\n\n\ninitial_devs::Int64 = 20\n: initial amount of high standard deviation kmer to test\n\n\nuser_min_clust::Int64 = 5\n: minimum size of a cluster, competes with clust_multiplier\n\n\nk::Int64 = 6\n: length of kmer sequences calculated\n\n\ndistfunc = euclidean\n: type of distance function calculated on the kmer sequences\n\n\ncenter = mean\n: sets the center of a centroid to the mean of the centroid\n\n\nverbose::Int64 = 1\n: when true, the status of the program will be printed to 'stdout'\n\n\ncycle_lim = 20\n: maximum number of cycles allowed in clustering call\n\n\ntriangle::Bool = false\n: controls whether or not the triangle inequality is used in calculations\n\n\ndegap_param::Bool = false\n: controls whether degap is used in consensus calculations\n\n\nPolish::Bool = false\n: if true, draws a consensus again from singletons after reassignment\n\n\np_value::Float64 = 0.01\n: statistical threshold for splitting decisions\n\n\n\n\nPerforms clustering and sequence consensus.\n\n\nOrder of process:\n\n\n\n\nRough clustering\n\n\nFine clustering\n\n\nConsensus of clusters\n\n\n\n\nRecommended \nradius\n for rough clustering: 0.01 Recommended \nradius\n for fine clustering: 1.0\n\n\nsource\n\n\n#\n\n\nRAD.kmer_split_clustering\n \n \nFunction\n.\n\n\nkmer_split_clustering(kmer_vecs, seqs; rough_radius::Float64 = 0.01, fine_radius::Float64 = 1.0,  reassign::Bool = true,\n                    clust_multiplier::Float64 = 1.0, min_devs::Int64 = 6, initial_devs::Int64 = 20,\n                    user_min_clust::Int64 = 5, k::Int64 = 6, distfunc = euclidean, center = mean,\n                    verbose::Int64 = 1, cycle_lim = 20, triangle::Bool = false, p_value::Float64 = 0.01)\n\n\n\n\nReturns the fine clustering result from the given sequences.\n\n\nsource\n\n\n#\n\n\nRAD.kmer_split_consensus\n \n \nFunction\n.\n\n\nkmer_split_consensus(kmer_vecs, seqs, fine_indices; verbose::Int64=1, distfunc=euclidean, reassign::Bool=true,\n                   k::Int64=6, degap_param::Bool=false, user_min_clust::Int64=5, Polish::Bool=true)\n\n\n\n\nReturns the consensus of the sequences after clustering.\n\n\nsource\n\n\n#\n\n\nRAD.get_ave_dists\n \n \nFunction\n.\n\n\nget_ave_dists(fine_indices, original_seqs, consensus_seqs; distfunc=euclidean, center=median, k::Int64=6)\n\n\n\n\nFinds the average distance using the declared distance function\n\n\nsource\n\n\n#\n\n\nRAD.clusterpipeline\n \n \nFunction\n.\n\n\nclusterpipeline(infile::String; \nKeyword Arguments\n )\n\n                     prefix = \n,\n                     outfile = \n,\n                     ref_file = \n,\n                     error_filter = 0.01,\n                     homopoly_filter = true,\n                     minlength = 20,\n                     maxlength = 1000000,\n                     trim_seqs = true,\n                     align_ref_frames = true,\n                     write_bad_seqs = false,\n                     write_aminoacids = true,\n                     minsize = 5,\n                     cycle_lim = 10,\n                     merge_differing_homopolymers = false,\n                     cluster_filedump_path = \n,\n                     post_filedump = false,\n                     rough_radius::Float64=0.01,\n                     fine_radius::Float64=1.0,\n                     reassign::Bool=true,\n                     clust_multiplier::Float64=1.0,\n                     min_devs::Int64=6,\n                     initial_devs::Int64=20,\n                     user_min_clust::Int64=5,\n                     k::Int64=6,\n                     distfunc=euclidean,\n                     center=mean,\n                     verbose::Int64=1,\n                     triangle::Bool=false,\n                     degap_param::Bool=false,\n                     Polish::Bool=true,\n                     p_value::Float64=0.01)\n\n\n\n\nArguments\n\n\n\n\nprefix = \"\"\n: prefix for names of sequences in output file (ie in case of multiple time points, etc.).\n\n\noutfile = \"\"\n: default is \"[infile name without extension]-clusters.fasta\".\n\n\nref_file = \"\"\n: panel of reference seqs \u2013 if provided, used to orient and trim nearest sequences in input file.\n\n\nerror_filter = 0.01\n: if the input is a \".fastq\" file, any sequence with a site with error greater than this value is removed before clustering.\n\n\nhomopoly_filter = true\n: if true, remove sequences with erroneous run-on homopolymer regions (or trim the sequences if this region is on an end) via hidden markov model inference.\n\n\nminlength = 20\n: removes sequences shorter than this prior to clustering.\n\n\nmaxlength = 1000000\n: removes sequences longer than this prior to clustering.\n\n\ntrim_seqs = true\n: if a reference panel is provided (\nref_file\n) and this is true, locally trims consensus seqs to nearest reference sequence\n\n\nalign_ref_frames = true\n: corrects codon reading frames of inferred consensus sequences.\n\n\nwrite_bad_seqs = false\n: write sequences with uncorrectable reading frames to file\n\n\nwrite_aminoacids = true\n: write amino acid translations of consensus sequences to file\n\n\nminsize = 5\n: throw away clusters/consensuses with fewer than this many reads.\n\n\ncycle_lim = 10\n : TODO\n\n\nmerge_differing_homopolymers = false\n: aggregates clusters with consensus seqs that only differ by a single gap in a homopolymer region.\n\n\ncluster_filedump_path = \"\"\n: if nonempty, writes original sequences to output files determined by resulting cluster in given directory. This string may also include a file name prefix.\n\n\npost_filedump\n: writes inferred consensus seqs to file after clustering, before aligning and trimming.\n\n\nrough_radius::Float64\n: distance between SNPs used in fine clustering\n\n\nfine_radius::Float64\n: distance between SNPs used in rough clustering\n\n\nreassign::Bool = true\n: indicates whether or not to reassign the rough singletons\n\n\n\n\nback to consensus sequences\n\n\n\n\nclust_multiplier::Float64 = 1.0\n: minimum non-error cluster size\n\n\nmin_devs::Int64 = 6\n: number of high standard deviation kmer to fine cluster on\n\n\ninitial_devs::Int64 = 20\n: initial amount of high standard deviation kmer to test\n\n\nuser_min_clust::Int64 = 5\n: minimum size of a cluster, competes with clust_multiplier\n\n\nk::Int64 = 6\n: length of kmer sequences calculated\n\n\ndistfunc = euclidean\n: type of distance function calculated on the kmer sequences\n\n\ncenter = mean\n: sets the center of a centroid to the mean of the centroid\n\n\nverbose::Int64 = 1\n: when true, the status of the program will be printed to 'stdout'\n\n\ncycle_lim = 20\n: maximum number of cycles allowed in clustering call\n\n\ntriangle::Bool = false\n: controls whether or not the triangle inequality is used in calculations\n\n\ndegap_param::Bool = false\n: controls whether degap is used in consensus calculations\n\n\nPolish::Bool = false\n: if true, draws a consensus again from singletons after reassignment\n\n\np_value::Float64 = 0.01\n: statistical threshold for splitting decisions\n\n\n\n\nA clustering pipeline for sequence files. Order of processes:\n\n\n\n\nError filter (if .fastq)\n\n\nLength filter\n\n\nHomopolymer filter\n\n\nLength filter again\n\n\nOrient (either to reference panel or inferred coarse cluster centroid)\n\n\nRough clustering\n\n\nFine clustering\n\n\nConsensus of clusters\n\n\n\n\nRecommended \nradius\n for rough clustering: 0.01 Recommended \nradius\n for fine clustering: 1.0\n\n\ninfile\n and \nref_file\n must be either .fasta or .fastq. If file is .fastq, then removes sequences with greater than \nerror_filter\n error.\n\n\nsource", 
            "title": "clusterpipeline"
        }, 
        {
            "location": "/clusterpipeline/#primary-clustering-and-pipeline-functions", 
            "text": "RAD.clusterpipeline  RAD.denoise  RAD.get_ave_dists  RAD.kmer_split_clustering  RAD.kmer_split_consensus   #  RAD.denoise     Function .  denoise(seqs;  keyword arguments  )\n\n                rough_radius::Float64 = 0.01,\n                fine_radius::Float64 = 1.0,\n                reassign::Bool = true,\n                clust_multiplier::Float64 = 1.0,\n                min_devs::Int64 = 6,\n                initial_devs::Int64 = 20,\n                user_min_clust::Int64 = 5,\n                k::Int64 = 6,\n                distfunc = euclidean,\n                center = mean,\n                verbose::Int64 = 1,\n                cycle_lim = 20,\n                triangle::Bool = false,\n                degap_param::Bool = false,\n                Polish::Bool = true,\n                p_value::Float64 = 0.01", 
            "title": "Primary Clustering and Pipeline Functions"
        }, 
        {
            "location": "/clusterpipeline/#arguments", 
            "text": "seqs : array containing the sequences to be operated on  rough_radius::Float64 : distance between SNPs used in fine clustering  fine_radius::Float64 : distance between SNPs used in rough clustering  reassign::Bool = true : indicates whether or not to reassign the rough singletons   back to consensus sequences   clust_multiplier::Float64 = 1.0 : minimum non-error cluster size  min_devs::Int64 = 6 : number of high standard deviation kmer to fine cluster on  initial_devs::Int64 = 20 : initial amount of high standard deviation kmer to test  user_min_clust::Int64 = 5 : minimum size of a cluster, competes with clust_multiplier  k::Int64 = 6 : length of kmer sequences calculated  distfunc = euclidean : type of distance function calculated on the kmer sequences  center = mean : sets the center of a centroid to the mean of the centroid  verbose::Int64 = 1 : when true, the status of the program will be printed to 'stdout'  cycle_lim = 20 : maximum number of cycles allowed in clustering call  triangle::Bool = false : controls whether or not the triangle inequality is used in calculations  degap_param::Bool = false : controls whether degap is used in consensus calculations  Polish::Bool = false : if true, draws a consensus again from singletons after reassignment  p_value::Float64 = 0.01 : statistical threshold for splitting decisions   Performs clustering and sequence consensus.  Order of process:   Rough clustering  Fine clustering  Consensus of clusters   Recommended  radius  for rough clustering: 0.01 Recommended  radius  for fine clustering: 1.0  source  #  RAD.kmer_split_clustering     Function .  kmer_split_clustering(kmer_vecs, seqs; rough_radius::Float64 = 0.01, fine_radius::Float64 = 1.0,  reassign::Bool = true,\n                    clust_multiplier::Float64 = 1.0, min_devs::Int64 = 6, initial_devs::Int64 = 20,\n                    user_min_clust::Int64 = 5, k::Int64 = 6, distfunc = euclidean, center = mean,\n                    verbose::Int64 = 1, cycle_lim = 20, triangle::Bool = false, p_value::Float64 = 0.01)  Returns the fine clustering result from the given sequences.  source  #  RAD.kmer_split_consensus     Function .  kmer_split_consensus(kmer_vecs, seqs, fine_indices; verbose::Int64=1, distfunc=euclidean, reassign::Bool=true,\n                   k::Int64=6, degap_param::Bool=false, user_min_clust::Int64=5, Polish::Bool=true)  Returns the consensus of the sequences after clustering.  source  #  RAD.get_ave_dists     Function .  get_ave_dists(fine_indices, original_seqs, consensus_seqs; distfunc=euclidean, center=median, k::Int64=6)  Finds the average distance using the declared distance function  source  #  RAD.clusterpipeline     Function .  clusterpipeline(infile::String;  Keyword Arguments  )\n\n                     prefix =  ,\n                     outfile =  ,\n                     ref_file =  ,\n                     error_filter = 0.01,\n                     homopoly_filter = true,\n                     minlength = 20,\n                     maxlength = 1000000,\n                     trim_seqs = true,\n                     align_ref_frames = true,\n                     write_bad_seqs = false,\n                     write_aminoacids = true,\n                     minsize = 5,\n                     cycle_lim = 10,\n                     merge_differing_homopolymers = false,\n                     cluster_filedump_path =  ,\n                     post_filedump = false,\n                     rough_radius::Float64=0.01,\n                     fine_radius::Float64=1.0,\n                     reassign::Bool=true,\n                     clust_multiplier::Float64=1.0,\n                     min_devs::Int64=6,\n                     initial_devs::Int64=20,\n                     user_min_clust::Int64=5,\n                     k::Int64=6,\n                     distfunc=euclidean,\n                     center=mean,\n                     verbose::Int64=1,\n                     triangle::Bool=false,\n                     degap_param::Bool=false,\n                     Polish::Bool=true,\n                     p_value::Float64=0.01)  Arguments   prefix = \"\" : prefix for names of sequences in output file (ie in case of multiple time points, etc.).  outfile = \"\" : default is \"[infile name without extension]-clusters.fasta\".  ref_file = \"\" : panel of reference seqs \u2013 if provided, used to orient and trim nearest sequences in input file.  error_filter = 0.01 : if the input is a \".fastq\" file, any sequence with a site with error greater than this value is removed before clustering.  homopoly_filter = true : if true, remove sequences with erroneous run-on homopolymer regions (or trim the sequences if this region is on an end) via hidden markov model inference.  minlength = 20 : removes sequences shorter than this prior to clustering.  maxlength = 1000000 : removes sequences longer than this prior to clustering.  trim_seqs = true : if a reference panel is provided ( ref_file ) and this is true, locally trims consensus seqs to nearest reference sequence  align_ref_frames = true : corrects codon reading frames of inferred consensus sequences.  write_bad_seqs = false : write sequences with uncorrectable reading frames to file  write_aminoacids = true : write amino acid translations of consensus sequences to file  minsize = 5 : throw away clusters/consensuses with fewer than this many reads.  cycle_lim = 10  : TODO  merge_differing_homopolymers = false : aggregates clusters with consensus seqs that only differ by a single gap in a homopolymer region.  cluster_filedump_path = \"\" : if nonempty, writes original sequences to output files determined by resulting cluster in given directory. This string may also include a file name prefix.  post_filedump : writes inferred consensus seqs to file after clustering, before aligning and trimming.  rough_radius::Float64 : distance between SNPs used in fine clustering  fine_radius::Float64 : distance between SNPs used in rough clustering  reassign::Bool = true : indicates whether or not to reassign the rough singletons   back to consensus sequences   clust_multiplier::Float64 = 1.0 : minimum non-error cluster size  min_devs::Int64 = 6 : number of high standard deviation kmer to fine cluster on  initial_devs::Int64 = 20 : initial amount of high standard deviation kmer to test  user_min_clust::Int64 = 5 : minimum size of a cluster, competes with clust_multiplier  k::Int64 = 6 : length of kmer sequences calculated  distfunc = euclidean : type of distance function calculated on the kmer sequences  center = mean : sets the center of a centroid to the mean of the centroid  verbose::Int64 = 1 : when true, the status of the program will be printed to 'stdout'  cycle_lim = 20 : maximum number of cycles allowed in clustering call  triangle::Bool = false : controls whether or not the triangle inequality is used in calculations  degap_param::Bool = false : controls whether degap is used in consensus calculations  Polish::Bool = false : if true, draws a consensus again from singletons after reassignment  p_value::Float64 = 0.01 : statistical threshold for splitting decisions   A clustering pipeline for sequence files. Order of processes:   Error filter (if .fastq)  Length filter  Homopolymer filter  Length filter again  Orient (either to reference panel or inferred coarse cluster centroid)  Rough clustering  Fine clustering  Consensus of clusters   Recommended  radius  for rough clustering: 0.01 Recommended  radius  for fine clustering: 1.0  infile  and  ref_file  must be either .fasta or .fastq. If file is .fastq, then removes sequences with greater than  error_filter  error.  source", 
            "title": "Arguments"
        }, 
        {
            "location": "/consensus/", 
            "text": "Consensus and Fine Cluster Splitting Functions\n\n\n\n\nRAD.are_homopolymers\n\n\nRAD.cluster_split\n\n\nRAD.fine_clustering\n\n\nRAD.gen_arrangements\n\n\nRAD.get_non_homopolymers\n\n\n\n\n#\n\n\nRAD.fine_clustering\n \n \nFunction\n.\n\n\nfine_clustering(kmer_vecs; rough_radius::Float64 = 0.01, fine_radius::Float64 = 1.0, clust_multiplier = 1.0,                          min_devs = 6, initial_devs = 20, user_min_clust = 10, distfunc = euclidean, center = mean,                         verbose::Int64 = 1, cycle_lim = 20, triangle::Bool = false, p_value::Float64 = 0.01)\n\n\nPreforms fine clustering on the already rough clustered sequences. \n\n\nsource\n\n\n#\n\n\nRAD.gen_arrangements\n \n \nFunction\n.\n\n\n gen_arrangements(k)\n\n\n\n\nReturns an array containing all possible kmer sequences of length k\n\n\nsource\n\n\n#\n\n\nRAD.cluster_split\n \n \nFunction\n.\n\n\ncluster_split(kmer_vecs, count, nuc_inds; rough_radius::Float64=0.01, fine_radius::Float64=1.0, clust_multiplier=1.0,\n                    min_devs=6, initial_devs=20, user_min_clust=10, distfunc=euclidean,\n                    center=mean, verbose::Int64=1, cycle_lim=20, triangle::Bool=false, p_value::Float64=0.01)\n\n\n\n\nDetermines if passed cluster is a 'real' cluster and recursively splits non-error clusters\n\n\nsource\n\n\n#\n\n\nRAD.get_non_homopolymers\n \n \nFunction\n.\n\n\nget_non_homopolymers(dev_inds::Array{Int64, 1}, nuc_inds; min_devs = 6)\n\n\n\n\nTakes in array of kmer indices. Returns the highest standard deviation non-homopolymer indices\n\n\nsource\n\n\n#\n\n\nRAD.are_homopolymers\n \n \nFunction\n.\n\n\nare_homopolymers(alignment::Tuple{String,String}; k = 6, polylen = 3)\n\n\n\n\nDetermines if the aligned kmers represent a homopolymer difference. If the kmers represent a homopolymer difference, the function returns true.\n\n\nsource", 
            "title": "consensus"
        }, 
        {
            "location": "/consensus/#consensus-and-fine-cluster-splitting-functions", 
            "text": "RAD.are_homopolymers  RAD.cluster_split  RAD.fine_clustering  RAD.gen_arrangements  RAD.get_non_homopolymers   #  RAD.fine_clustering     Function .  fine_clustering(kmer_vecs; rough_radius::Float64 = 0.01, fine_radius::Float64 = 1.0, clust_multiplier = 1.0,                          min_devs = 6, initial_devs = 20, user_min_clust = 10, distfunc = euclidean, center = mean,                         verbose::Int64 = 1, cycle_lim = 20, triangle::Bool = false, p_value::Float64 = 0.01)  Preforms fine clustering on the already rough clustered sequences.   source  #  RAD.gen_arrangements     Function .   gen_arrangements(k)  Returns an array containing all possible kmer sequences of length k  source  #  RAD.cluster_split     Function .  cluster_split(kmer_vecs, count, nuc_inds; rough_radius::Float64=0.01, fine_radius::Float64=1.0, clust_multiplier=1.0,\n                    min_devs=6, initial_devs=20, user_min_clust=10, distfunc=euclidean,\n                    center=mean, verbose::Int64=1, cycle_lim=20, triangle::Bool=false, p_value::Float64=0.01)  Determines if passed cluster is a 'real' cluster and recursively splits non-error clusters  source  #  RAD.get_non_homopolymers     Function .  get_non_homopolymers(dev_inds::Array{Int64, 1}, nuc_inds; min_devs = 6)  Takes in array of kmer indices. Returns the highest standard deviation non-homopolymer indices  source  #  RAD.are_homopolymers     Function .  are_homopolymers(alignment::Tuple{String,String}; k = 6, polylen = 3)  Determines if the aligned kmers represent a homopolymer difference. If the kmers represent a homopolymer difference, the function returns true.  source", 
            "title": "Consensus and Fine Cluster Splitting Functions"
        }
    ]
}